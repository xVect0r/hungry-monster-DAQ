// Testbench code generated by Chatgpt on previous project context with current capture file

`timescale 1ns/1ps

module tb_capture_controller;

    localparam DATA_W = 32;
    localparam USER_W = 8;
    localparam TS_W   = 32;

    logic clk = 0;
    logic rst_n;

    always #4 clk = ~clk;  // 125 MHz clock (8 ns period)

    // AXI Slave (input to DUT)
    logic [DATA_W-1:0] s_tdata;
    logic              s_tvalid;
    logic              s_tready;
    logic              s_tlast;
    logic [USER_W-1:0] s_tuser;

    // AXI Master (output from DUT)
    logic [DATA_W-1:0] m_tdata;
    logic              m_tvalid;
    logic              m_tready;
    logic              m_tlast;
    logic [USER_W-1:0] m_tuser;

    // Trigger / control
    logic trigger_in;
    logic [15:0] debounce_cycles;
    logic [15:0] capture_length;

    logic [TS_W-1:0] timestamp_counter;
    logic [TS_W-1:0] latched_timestamp;
    logic capture_active;

    // DUT
    axi_capture_controller #(
        .DATA_W(DATA_W),
        .USER_W(USER_W),
        .TS_W(TS_W)
    ) dut (
        .clk(clk),
        .rst_n(rst_n),

        .s_tdata(s_tdata),
        .s_tvalid(s_tvalid),
        .s_tready(s_tready),
        .s_tlast(s_tlast),
        .s_tuser(s_tuser),

        .m_tdata(m_tdata),
        .m_tvalid(m_tvalid),
        .m_tready(m_tready),
        .m_tlast(m_tlast),
        .m_tuser(m_tuser),

        .trigger_in(trigger_in),
        .debounce_cycles(debounce_cycles),
        .capture_length(capture_length),

        .timestamp_counter(timestamp_counter),
        .latched_timestamp(latched_timestamp),
        .capture_active(capture_active)
    );

    // Timestamp free-running counter
    always_ff @(posedge clk) begin
        if (!rst_n)
            timestamp_counter <= 0;
        else
            timestamp_counter <= timestamp_counter + 1;
    end

    // Stimulus
    initial begin
        rst_n = 0;
        s_tvalid = 0;
        s_tdata  = 0;
        s_tlast  = 0;
        s_tuser  = 0;
        m_tready = 1;
        trigger_in = 0;

        debounce_cycles = 3;
        capture_length  = 8;

        #50;
        rst_n = 1;

        // Continuous upstream data
        fork
            begin
                forever begin
                    @(posedge clk);
                    s_tvalid <= 1;
                    s_tdata  <= s_tdata + 1;
                end
            end
        join_none

        // Fire trigger
        #40;
        @(posedge clk);
        trigger_in <= 1;
        @(posedge clk);
        trigger_in <= 0;

        // Mid-capture backpressure
        #100;
        @(posedge clk);
        m_tready <= 0;

        #40;
        @(posedge clk);
        m_tready <= 1;

        // Attempt retrigger during capture
        #20;
        @(posedge clk);
        trigger_in <= 1;
        @(posedge clk);
        trigger_in <= 0;

        #300;
        $finish;
    end

    // Monitoring
    int beat_count = 0;

    always_ff @(posedge clk) begin
        if (!rst_n)
            beat_count <= 0;
        else if (m_tvalid && m_tready) begin
            beat_count <= beat_count + 1;

            if (m_tlast) begin
                if (beat_count != capture_length - 1)
                    $fatal("TLAST incorrect position. Count=%0d", beat_count);

                beat_count <= 0;
                $display("Capture completed correctly at time %0t", $time);
            end
        end
    end

endmodule
